/* automatically generated by rust-bindgen 0.60.1 */

pub const EDLIB_STATUS_OK: u32 = 0;
pub const EDLIB_STATUS_ERROR: u32 = 1;
pub const EDLIB_EDOP_MATCH: u32 = 0;
pub const EDLIB_EDOP_INSERT: u32 = 1;
pub const EDLIB_EDOP_DELETE: u32 = 2;
pub const EDLIB_EDOP_MISMATCH: u32 = 3;
#[doc = " Global method. This is the standard method."]
#[doc = " Useful when you want to find out how similar is first sequence to second sequence."]
pub const EdlibAlignMode_EDLIB_MODE_NW: EdlibAlignMode = 0;
#[doc = " Prefix method. Similar to global method, but with a small twist - gap at query end is not penalized."]
#[doc = " What that means is that deleting elements from the end of second sequence is \"free\"!"]
#[doc = " For example, if we had \"AACT\" and \"AACTGGC\", edit distance would be 0, because removing \"GGC\" from the end"]
#[doc = " of second sequence is \"free\" and does not count into total edit distance. This method is appropriate"]
#[doc = " when you want to find out how well first sequence fits at the beginning of second sequence."]
pub const EdlibAlignMode_EDLIB_MODE_SHW: EdlibAlignMode = 1;
#[doc = " Infix method. Similar as prefix method, but with one more twist - gaps at query end and start are"]
#[doc = " not penalized. What that means is that deleting elements from the start and end of second sequence is \"free\"!"]
#[doc = " For example, if we had ACT and CGACTGAC, edit distance would be 0, because removing CG from the start"]
#[doc = " and GAC from the end of second sequence is \"free\" and does not count into total edit distance."]
#[doc = " This method is appropriate when you want to find out how well first sequence fits at any part of"]
#[doc = " second sequence."]
#[doc = " For example, if your second sequence was a long text and your first sequence was a sentence from that text,"]
#[doc = " but slightly scrambled, you could use this method to discover how scrambled it is and where it fits in"]
#[doc = " that text. In bioinformatics, this method is appropriate for aligning read to a sequence."]
pub const EdlibAlignMode_EDLIB_MODE_HW: EdlibAlignMode = 2;
#[doc = " Alignment methods - how should Edlib treat gaps before and after query?"]
pub type EdlibAlignMode = ::std::os::raw::c_uint;
#[doc = "!< Find edit distance and end locations."]
pub const EdlibAlignTask_EDLIB_TASK_DISTANCE: EdlibAlignTask = 0;
#[doc = "!< Find edit distance, end locations and start locations."]
pub const EdlibAlignTask_EDLIB_TASK_LOC: EdlibAlignTask = 1;
#[doc = "!< Find edit distance, end locations and start locations and alignment path."]
pub const EdlibAlignTask_EDLIB_TASK_PATH: EdlibAlignTask = 2;
#[doc = " Alignment tasks - what do you want Edlib to do?"]
pub type EdlibAlignTask = ::std::os::raw::c_uint;
#[doc = "!< Match: 'M', Insertion: 'I', Deletion: 'D', Mismatch: 'M'."]
pub const EdlibCigarFormat_EDLIB_CIGAR_STANDARD: EdlibCigarFormat = 0;
#[doc = "!< Match: '=', Insertion: 'I', Deletion: 'D', Mismatch: 'X'."]
pub const EdlibCigarFormat_EDLIB_CIGAR_EXTENDED: EdlibCigarFormat = 1;
#[doc = " Describes cigar format."]
#[doc = " @see http://samtools.github.io/hts-specs/SAMv1.pdf"]
#[doc = " @see http://drive5.com/usearch/manual/cigar.html"]
pub type EdlibCigarFormat = ::std::os::raw::c_uint;
#[doc = " @brief Defines two given characters as equal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EdlibEqualityPair {
    pub first: ::std::os::raw::c_char,
    pub second: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_EdlibEqualityPair() {
    assert_eq!(
        ::std::mem::size_of::<EdlibEqualityPair>(),
        2usize,
        concat!("Size of: ", stringify!(EdlibEqualityPair))
    );
    assert_eq!(
        ::std::mem::align_of::<EdlibEqualityPair>(),
        1usize,
        concat!("Alignment of ", stringify!(EdlibEqualityPair))
    );
    fn test_field_first() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibEqualityPair>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).first) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibEqualityPair),
                "::",
                stringify!(first)
            )
        );
    }
    test_field_first();
    fn test_field_second() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibEqualityPair>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).second) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibEqualityPair),
                "::",
                stringify!(second)
            )
        );
    }
    test_field_second();
}
#[doc = " @brief Configuration object for edlibAlign() function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EdlibAlignConfig {
    #[doc = " Set k to non-negative value to tell edlib that edit distance is not larger than k."]
    #[doc = " Smaller k can significantly improve speed of computation."]
    #[doc = " If edit distance is larger than k, edlib will set edit distance to -1."]
    #[doc = " Set k to negative value and edlib will internally auto-adjust k until score is found."]
    pub k: ::std::os::raw::c_int,
    #[doc = " Alignment method."]
    #[doc = " EDLIB_MODE_NW: global (Needleman-Wunsch)"]
    #[doc = " EDLIB_MODE_SHW: prefix. Gap after query is not penalized."]
    #[doc = " EDLIB_MODE_HW: infix. Gaps before and after query are not penalized."]
    pub mode: EdlibAlignMode,
    #[doc = " Alignment task - tells Edlib what to calculate. Less to calculate, faster it is."]
    #[doc = " EDLIB_TASK_DISTANCE - find edit distance and end locations of optimal alignment paths in target."]
    #[doc = " EDLIB_TASK_LOC - find edit distance and start and end locations of optimal alignment paths in target."]
    #[doc = " EDLIB_TASK_PATH - find edit distance, alignment path (and start and end locations of it in target)."]
    pub task: EdlibAlignTask,
    #[doc = " List of pairs of characters, where each pair defines two characters as equal."]
    #[doc = " This way you can extend edlib's definition of equality (which is that each character is equal only"]
    #[doc = " to itself)."]
    #[doc = " This can be useful if you have some wildcard characters that should match multiple other characters,"]
    #[doc = " or e.g. if you want edlib to be case insensitive."]
    #[doc = " Can be set to NULL if there are none."]
    pub additionalEqualities: *mut EdlibEqualityPair,
    #[doc = " Number of additional equalities, which is non-negative number."]
    #[doc = " 0 if there are none."]
    pub additionalEqualitiesLength: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EdlibAlignConfig() {
    assert_eq!(
        ::std::mem::size_of::<EdlibAlignConfig>(),
        32usize,
        concat!("Size of: ", stringify!(EdlibAlignConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<EdlibAlignConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(EdlibAlignConfig))
    );
    fn test_field_k() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignConfig),
                "::",
                stringify!(k)
            )
        );
    }
    test_field_k();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignConfig),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_task() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).task) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignConfig),
                "::",
                stringify!(task)
            )
        );
    }
    test_field_task();
    fn test_field_additionalEqualities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).additionalEqualities) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignConfig),
                "::",
                stringify!(additionalEqualities)
            )
        );
    }
    test_field_additionalEqualities();
    fn test_field_additionalEqualitiesLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).additionalEqualitiesLength) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignConfig),
                "::",
                stringify!(additionalEqualitiesLength)
            )
        );
    }
    test_field_additionalEqualitiesLength();
}
extern "C" {
    #[doc = " Helper method for easy construction of configuration object."]
    #[doc = " @return Configuration object filled with given parameters."]
    pub fn edlibNewAlignConfig(
        k: ::std::os::raw::c_int,
        mode: EdlibAlignMode,
        task: EdlibAlignTask,
        additionalEqualities: *mut EdlibEqualityPair,
        additionalEqualitiesLength: ::std::os::raw::c_int,
    ) -> EdlibAlignConfig;
}
extern "C" {
    #[doc = " @return Default configuration object, with following defaults:"]
    #[doc = "         k = -1, mode = EDLIB_MODE_NW, task = EDLIB_TASK_DISTANCE, no additional equalities."]
    pub fn edlibDefaultAlignConfig() -> EdlibAlignConfig;
}
#[doc = " Container for results of alignment done by edlibAlign() function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EdlibAlignResult {
    #[doc = " EDLIB_STATUS_OK or EDLIB_STATUS_ERROR. If error, all other fields will have undefined values."]
    pub status: ::std::os::raw::c_int,
    #[doc = " -1 if k is non-negative and edit distance is larger than k."]
    pub editDistance: ::std::os::raw::c_int,
    #[doc = " Array of zero-based positions in target where optimal alignment paths end."]
    #[doc = " If gap after query is penalized, gap counts as part of query (NW), otherwise not."]
    #[doc = " Set to NULL if edit distance is larger than k."]
    #[doc = " If you do not free whole result object using edlibFreeAlignResult(), do not forget to use free()."]
    pub endLocations: *mut ::std::os::raw::c_int,
    #[doc = " Array of zero-based positions in target where optimal alignment paths start,"]
    #[doc = " they correspond to endLocations."]
    #[doc = " If gap before query is penalized, gap counts as part of query (NW), otherwise not."]
    #[doc = " Set to NULL if not calculated or if edit distance is larger than k."]
    #[doc = " If you do not free whole result object using edlibFreeAlignResult(), do not forget to use free()."]
    pub startLocations: *mut ::std::os::raw::c_int,
    #[doc = " Number of end (and start) locations."]
    pub numLocations: ::std::os::raw::c_int,
    #[doc = " Alignment is found for first pair of start and end locations."]
    #[doc = " Set to NULL if not calculated."]
    #[doc = " Alignment is sequence of numbers: 0, 1, 2, 3."]
    #[doc = " 0 stands for match."]
    #[doc = " 1 stands for insertion to target."]
    #[doc = " 2 stands for insertion to query."]
    #[doc = " 3 stands for mismatch."]
    #[doc = " Alignment aligns query to target from begining of query till end of query."]
    #[doc = " If gaps are not penalized, they are not in alignment."]
    #[doc = " If you do not free whole result object using edlibFreeAlignResult(), do not forget to use free()."]
    pub alignment: *mut ::std::os::raw::c_uchar,
    #[doc = " Length of alignment."]
    pub alignmentLength: ::std::os::raw::c_int,
    #[doc = " Number of different characters in query and target together."]
    pub alphabetLength: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EdlibAlignResult() {
    assert_eq!(
        ::std::mem::size_of::<EdlibAlignResult>(),
        48usize,
        concat!("Size of: ", stringify!(EdlibAlignResult))
    );
    assert_eq!(
        ::std::mem::align_of::<EdlibAlignResult>(),
        8usize,
        concat!("Alignment of ", stringify!(EdlibAlignResult))
    );
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignResult>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignResult),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_editDistance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignResult>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).editDistance) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignResult),
                "::",
                stringify!(editDistance)
            )
        );
    }
    test_field_editDistance();
    fn test_field_endLocations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignResult>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).endLocations) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignResult),
                "::",
                stringify!(endLocations)
            )
        );
    }
    test_field_endLocations();
    fn test_field_startLocations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignResult>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).startLocations) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignResult),
                "::",
                stringify!(startLocations)
            )
        );
    }
    test_field_startLocations();
    fn test_field_numLocations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignResult>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numLocations) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignResult),
                "::",
                stringify!(numLocations)
            )
        );
    }
    test_field_numLocations();
    fn test_field_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignResult>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignResult),
                "::",
                stringify!(alignment)
            )
        );
    }
    test_field_alignment();
    fn test_field_alignmentLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignResult>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alignmentLength) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignResult),
                "::",
                stringify!(alignmentLength)
            )
        );
    }
    test_field_alignmentLength();
    fn test_field_alphabetLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<EdlibAlignResult>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alphabetLength) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(EdlibAlignResult),
                "::",
                stringify!(alphabetLength)
            )
        );
    }
    test_field_alphabetLength();
}
extern "C" {
    #[doc = " Frees memory in EdlibAlignResult that was allocated by edlib."]
    #[doc = " If you do not use it, make sure to free needed members manually using free()."]
    pub fn edlibFreeAlignResult(result: EdlibAlignResult);
}
extern "C" {
    #[doc = " Aligns two sequences (query and target) using edit distance (levenshtein distance)."]
    #[doc = " Through config parameter, this function supports different alignment methods (global, prefix, infix),"]
    #[doc = " as well as different modes of search (tasks)."]
    #[doc = " It always returns edit distance and end locations of optimal alignment in target."]
    #[doc = " It optionally returns start locations of optimal alignment in target and alignment path,"]
    #[doc = " if you choose appropriate tasks."]
    #[doc = " @param [in] query  First sequence."]
    #[doc = " @param [in] queryLength  Number of characters in first sequence."]
    #[doc = " @param [in] target  Second sequence."]
    #[doc = " @param [in] targetLength  Number of characters in second sequence."]
    #[doc = " @param [in] config  Additional alignment parameters, like alignment method and wanted results."]
    #[doc = " @return  Result of alignment, which can contain edit distance, start and end locations and alignment path."]
    #[doc = "          Make sure to clean up the object using edlibFreeAlignResult() or by manually freeing needed members."]
    pub fn edlibAlign(
        query: *const ::std::os::raw::c_char,
        queryLength: ::std::os::raw::c_int,
        target: *const ::std::os::raw::c_char,
        targetLength: ::std::os::raw::c_int,
        config: EdlibAlignConfig,
    ) -> EdlibAlignResult;
}
extern "C" {
    #[doc = " Builds cigar string from given alignment sequence."]
    #[doc = " @param [in] alignment  Alignment sequence."]
    #[doc = "     0 stands for match."]
    #[doc = "     1 stands for insertion to target."]
    #[doc = "     2 stands for insertion to query."]
    #[doc = "     3 stands for mismatch."]
    #[doc = " @param [in] alignmentLength"]
    #[doc = " @param [in] cigarFormat  Cigar will be returned in specified format."]
    #[doc = " @return Cigar string."]
    #[doc = "     I stands for insertion."]
    #[doc = "     D stands for deletion."]
    #[doc = "     X stands for mismatch. (used only in extended format)"]
    #[doc = "     = stands for match. (used only in extended format)"]
    #[doc = "     M stands for (mis)match. (used only in standard format)"]
    #[doc = "     String is null terminated."]
    #[doc = "     Needed memory is allocated and given pointer is set to it."]
    #[doc = "     Do not forget to free it later using free()!"]
    pub fn edlibAlignmentToCigar(
        alignment: *const ::std::os::raw::c_uchar,
        alignmentLength: ::std::os::raw::c_int,
        cigarFormat: EdlibCigarFormat,
    ) -> *mut ::std::os::raw::c_char;
}
